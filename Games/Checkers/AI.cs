// Generated by Creer at 01:14AM on July 22, 2015 UTC, git hash: '6ae07398e95534176c2e851c2d21269933edce81'
// This is where you build your AI for the Checkers game.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
// <<-- Creer-Merge: usings -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
// you can add addtional using(s) here
// <<-- /Creer-Merge: usings -->>

namespace Joueur.cs.Games.Checkers
{
    class AI : BaseAI
    {
        #region Properties
        #pragma warning disable 0169 // the never assigned warning between here is incorrect. We set it for you via reflection. So this will remove if from the Error list.
        /// <summary>
        /// This is the Game object itself, it contains all the information about the current game
        /// </summary>
        public readonly Checkers.Game Game;
        /// <summary>
        /// This is your AI's player. This AI class is not a player, but it should command this Player.
        /// </summary>
        public readonly Checkers.Player Player;
        #pragma warning restore 0169

        // <<-- Creer-Merge: properties -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

        private bool CantMove = false;
        private Checkers.Checker ForceChecker;
        private class Point
        {
            public int X = 0;
            public int Y = 0;
            public bool RequiresJump = false;

        }
        private static Random RNG = new Random();
        private Checkers.Checker[,] CheckerMap;

        // <<-- /Creer-Merge: properties -->>
        #endregion


        #region Methods
        /// <summary>
        /// This returns your AI's name to the game server. Just replace the string.
        /// </summary>
        /// <returns>string of you AI's name.</returns>
        public override string GetName()
        {
            // <<-- Creer-Merge: get-name -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
            return "Checkers C# Player"; // REPLACE THIS WITH YOUR TEAM NAME!
            // <<-- /Creer-Merge: get-name -->>
        }

        /// <summary>
        /// This is automatically called when the game first starts, once the Game object and all GameObjects have been initialized, but before any players do anything.
        /// </summary>
        /// <remarks>
        /// This is a good place to initialize any variables you add to your AI, or start tracking game objects.
        /// </remarks>
        public override void Start()
        {
            // <<-- Creer-Merge: start -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

            this.CheckerMap = new Checkers.Checker[this.Game.BoardWidth, this.Game.BoardHeight];

            this.ClearCheckersMap();

            // <<-- /Creer-Merge: start -->>
        }

        /// <summary>
        /// This is automatically called every time the game (or anything in it) updates.
        /// </summary>
        /// <remarks>
        /// If a function you call triggers an update this will be called before that function returns.
        /// </remarks>
        public override void GameUpdated()
        {
            // <<-- Creer-Merge: game-updated -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

            this.ClearCheckersMap();

            this.ForceChecker = null;
            this.CantMove = false;

            foreach (var checker in this.Game.Checkers)
            {
                this.CheckerMap[checker.X, checker.Y] = checker;

                if (checker.Owner == this.Player && checker == this.Game.CheckerMoved)
                {
                    if (this.Game.CheckerMovedJumped)
                    {
                        this.ForceChecker = checker;
                    }
                    else
                    {
                        this.CantMove = true;
                    }
                }
            }

            // <<-- /Creer-Merge: game-updated -->>
        }

        /// <summary>
        /// This is automatically called when the game ends.
        /// </summary>
        /// <remarks>
        /// You can do any cleanup of you AI here, or do custom logging. After this function returns the application will close.
        /// </remarks>
        /// <param name="won">true if your player won, false otherwise</param>
        /// <param name="reason">a string explaining why you won or lost</param>
        public override void Ended(bool won, string reason)
        {
            // <<-- Creer-Merge: ended -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
            base.Ended(won, reason);
            // <<-- /Creer-Merge: ended -->>
        }


        /// <summary>
        /// This is called every time the AI is asked to respond with a command during their turn
        /// </summary>
        /// <returns>represents if you want to end your turn. true means end the turn, false means to keep your turn going and re-call runTurn()</returns>
        public bool RunTurn()
        {
            // <<-- Creer-Merge: runTurn -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

            bool cont = true;

            while(cont)
            {
                Checkers.Checker checker = null;
                Point point = null;

                this.FindMove(out checker, out point);

                if (checker != null && point != null)
                {
                    checker.Move(point.X, point.Y);
                }
                else
                {
                    cont = false; // as we couldn't find any valid moves
                }
            }

            return true;

            // <<-- /Creer-Merge: runTurn -->>
        }


        // <<-- Creer-Merge: methods -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        
        private void ClearCheckersMap()
        {
            for (int x = 0; x < this.Game.BoardWidth; x++)
            {
                for (int y = 0; y < this.Game.BoardWidth; y++)
                {
                    this.CheckerMap[x, y] = null;
                }
            }
        }

        private bool FindMove(out Checkers.Checker forChecker, out Point toPoint)
        {
            forChecker = null;
            toPoint = null;
            if (this.CantMove)
            {
                return false;
            }

            List<Checkers.Checker> checkers;

            if (this.ForceChecker != null)
            {
                checkers = new List<Checkers.Checker>(1);
                checkers.Add(this.ForceChecker);
            }
            else
            {
                checkers = new List<Checkers.Checker>(this.Player.Checkers.Count);
                foreach (var checker in this.Player.Checkers)
                {
                    checkers.Add(checker);
                }
            }

            var yDirection = this.Player.YDirection;

            AI.Shuffle<Checkers.Checker>(checkers);

            foreach(var checker in checkers)
            {
                var neighbors = new List<Point>();
                neighbors.Add(new Point { X = checker.X + 1, Y = checker.Y + yDirection });
                neighbors.Add(new Point { X = checker.X - 1, Y = checker.Y + yDirection });

                if (checker.Kinged)
                {
                    neighbors.Add(new Point { X = checker.X + 1, Y = checker.Y - yDirection });
                    neighbors.Add(new Point { X = checker.X - 1, Y = checker.Y - yDirection });
                }

                AI.Shuffle<Point>(neighbors);

                while (neighbors.Count > 0)
                {
                    var neighbor = neighbors[0];
                    neighbors.RemoveAt(0);

                    if (neighbor.X >= this.Game.BoardWidth || neighbor.X < 0 || neighbor.Y >= this.Game.BoardHeight || neighbor.Y < 0)
                    {
                        continue; // because it is out of bound of the game board
                    }

                    if (this.ForceChecker != null) // then we must jump
                    {
                        if (neighbor.RequiresJump)
                        {
                            forChecker = checker;
                            toPoint = neighbor;
                            return true;
                        }
                    }
                    else
                    {
                        var jumping = this.CheckerMap[neighbor.X, neighbor.Y];
                        if (jumping == null) // then there is no checker there, so it is valid!
                        {
                            forChecker = checker;
                            toPoint = neighbor;
                            return true;
                        }
                        else if (jumping.Owner != checker.Owner) // there is one to jump, so let's try to jump it
                        {
                            if (!neighbor.RequiresJump)
                            {
                                int dx = neighbor.X - checker.X;
                                int dy = neighbor.Y - checker.Y;

                                neighbors.Add(new Point { X = neighbor.X + dx, Y = neighbor.Y + dy, RequiresJump = true });
                            }
                        }
                    }
                }
            }

            return false; // as we couldn't find any valid moves
        }

        public static void Shuffle<T>(IList<T> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = RNG.Next(n + 1);
                T value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        // <<-- /Creer-Merge: methods -->>
        #endregion
    }
}
